[{"content":"python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 \u0026#34;\u0026#34;\u0026#34; ##高德经纬度（gcj02）转换为天地图经纬度（cgcs2000/WGS84） #lon_2000,lat_2000=gcj02towgs84(lon_GD,lat_GD) \u0026#34;\u0026#34;\u0026#34; import math #常量定义 pi = 3.1415926535897932384626 # π a = 6378245.0 # 长半轴 ee = 0.00669342162296594323 # 扁率 \u0026#34;\u0026#34;\u0026#34; #改正量计算 \u0026#34;\u0026#34;\u0026#34; def delta(lng,lat): lat_rad = lat / 180.0 * pi#纬度的弧度表达 #中间量 magic = 1 - ee * sin(lat_rad) * sin(lat_rad) magic = math.sin(lat_rad) magic = 1 - ee * magic * magic sqrtmagic = math.sqrt(magic) dlat = transformlat(lng - 105.0, lat - 35.0) dlng = transformlng(lng - 105.0, lat - 35.0) dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi) dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi) return [dlng, dlat] def transformlat(lng, lat): ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \\ 0.1 * lng * lat + 0.2 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lat * pi) + 40.0 * math.sin(lat / 3.0 * pi)) * 2.0 / 3.0 ret += (160.0 * math.sin(lat / 12.0 * pi) + 320 * math.sin(lat * pi / 30.0)) * 2.0 / 3.0 return ret def transformlng(lng, lat): ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \\ 0.1 * lng * lat + 0.1 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lng * pi) + 40.0 * math.sin(lng / 3.0 * pi)) * 2.0 / 3.0 ret += (150.0 * math.sin(lng / 12.0 * pi) + 300.0 * math.sin(lng / 30.0 * pi)) * 2.0 / 3.0 return ret def out_of_china(lng, lat): \u0026#34;\u0026#34;\u0026#34; 判断是否在国内，不在国内不做偏移 :param lng: :param lat: :return: \u0026#34;\u0026#34;\u0026#34; if lng \u0026lt; 72.004 or lng \u0026gt; 137.8347: return True if lat \u0026lt; 0.8293 or lat \u0026gt; 55.8271: return True return False \u0026#34;\u0026#34;\u0026#34; GCJ02(火星坐标系，高德)转WGS84(CGCS2000),与https://tool.lu/coordinate/一致 :param gc_lng:GCJ02(火星坐标系)经度,degree :param gc_lat:GCJ02(火星坐标系)纬度,degree :return:WGS84(CGCS2000)下的经度(degree)和纬度(degree) \u0026#34;\u0026#34;\u0026#34; def gcj02towgs84(gc_lng, gc_lat): if out_of_china(gc_lng, gc_lat): return gc_lng, gc_lat #改正量计算 dlng, dlat=delta(gc_lng, gc_lat) lat = gc_lat - dlat lng = gc_lng - dlng return [lng, lat] PHP代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /** * 获取转换后经纬度入口 * @param $lng * @param $lat * @return array */ public function gcj02towgs84($lng,$lat) { if ($this-\u0026gt;out_of_china($lng,$lat)){ return array( \u0026#39;lng\u0026#39;=\u0026gt;$lng, \u0026#39;lat\u0026#39;=\u0026gt;$lat ); } //改正量计算 $snap=$this-\u0026gt;delta($lng,$lat); $gc_lat = $lat - $snap[\u0026#39;lat\u0026#39;]; $gc_lng = $lng - $snap[\u0026#39;lng\u0026#39;]; return array( \u0026#39;lng\u0026#39;=\u0026gt;$gc_lng, \u0026#39;lat\u0026#39;=\u0026gt;$gc_lat ); } public function delta($lng,$lat){ //常量定义 $pi = 3.1415926535897932384626; // π $a = 6378245.0; // 长半轴 $ee = 0.00669342162296594323; // 扁率 $lat_rad=$lat / 180.0 * $pi;//纬度的弧度表达 $magic=sin($lat_rad); $magic=1 - $ee * $magic *$magic; $sqrtmagic=sqrt($magic); $dlat=$this-\u0026gt;transformlat($lng - 105.0, $lat - 35.0); $dlng=$this-\u0026gt;transformlng($lng - 105.0, $lat - 35.0); $dlat=($dlat * 180.0) / (($a * (1 - $ee)) / ($magic * $sqrtmagic) * $pi); $dlng=($dlng * 180.0) / ($a / $sqrtmagic * cos( $lat_rad) * $pi); return array( \u0026#39;lng\u0026#39;=\u0026gt;$dlng, \u0026#39;lat\u0026#39;=\u0026gt;$dlat ); } public function transformlng($lng,$lat){ $pi = 3.1415926535897932384626; // π $ret=300.0 + $lng + 2.0 * $lat + 0.1 * $lng * $lng + 0.1 * $lng * $lat + 0.1 * sqrt(abs($lng)); $ret += (20.0 * sin(6.0 * $lng * $pi) + 20.0 * sin(2.0 * $lng * $pi)) * 2.0 / 3.0; $ret += (20.0 * sin($lng * $pi) + 40.0 * sin($lng / 3.0 * $pi)) * 2.0 / 3.0; $ret += (150.0 * sin($lng / 12.0 * $pi) + 300 * sin($lng / 30.0* $pi)) * 2.0 / 3.0; return $ret; } public function transformlat($lng,$lat){ $pi = 3.1415926535897932384626; // π $ret=-100.0 + 2.0 * $lng + 3.0 * $lat + 0.2 * $lat * $lat + 0.1 * $lng * $lat + 0.2 * sqrt(abs($lng)); $ret += (20.0 * sin(6.0 * $lng * $pi) + 20.0 * sin(2.0 * $lng * $pi)) * 2.0 / 3.0; $ret += (20.0 * sin($lat * $pi) + 40.0 * sin($lat / 3.0 * $pi)) * 2.0 / 3.0; $ret += (160.0 * sin($lat / 12.0 * $pi) + 320 * sin($lat * $pi / 30.0)) * 2.0 / 3.0; return $ret; } public function out_of_china($lng,$lat){ if ($lng \u0026lt; 72.004 || $lng \u0026gt; 137.8347){ return true; } if ($lat \u0026lt; 0.8293 || $lat \u0026gt; 55.8271){ return true; } return false; } ","permalink":"https://jouzeyu.com/posts/note_202200718/","summary":"人的大脑倾向于更容易获得的答案，而非更正确的答案。","title":"高德地图转天地图"},{"content":"问题说明 我在系统中设计了一个字段，sort_weight，意为排序比重，当这个值越大，就返回越靠前，默认初始化填充数据的时候，我都是默认传入的0，但是当我接口调用的时候发现，返回的数据并不是预想的，出现了随机和重复，尤其是分页中最为明显；\n问题分析 经过谷歌后，我找到了出现该问题的所在。\n起初的想法：当order by 的字段相同时，应该是按照表的扫描顺序，返回，让我简单来示例下：\nid name sort_weight 1 abc 0 2 test 0 3 123 0 我起初的想法是，数据分页时需要根据数据记录创建时间sort_weight字段倒序，即使用order by sort_weight desc，这时因为sort_weight相同，返回id顺序应该是1，2，3，但是实际上当order by的字段相同的时候 系统对数据的排序可能变得随机，即一会儿这条数据在前面，一会儿这条数据在后面了 ，所以当翻页的时候我们很容易便看到了重复的数据。\n后来查阅资料，发现这种现象是“故意”设计的。 如果没有指定ORDER BY语句，则SQL Server（或任何RDBMS）不保证以特定顺序返回结果。 有些人认为，如果没有指定order by子句，行总是以聚簇索引顺序或物理磁盘顺序返回。 然而，这是不正确的，因为在查询处理期间可以改变行顺序的许多因素，例如并行的HASH连接是更改行顺序的操作符的一个很好的例子。\n如果指定ORDER BY语句，SQL Server将对行进行排序，并按请求的顺序返回。 但是，如果该顺序不是确定性的，即可能有重复的值，则在每个具有相同值的组中，由于与上述相同的原因，该顺序是“随机的”。 解决办法 确保确定性顺序的唯一方法是在ORDER BY子句中包含保证的唯一列或列组（例如主键）。\n","permalink":"https://jouzeyu.com/posts/note_20220628/","summary":"人的大脑倾向于更容易获得的答案，而非更正确的答案。","title":"mysql 排序错乱问题"},{"content":" 想写点详细的东西，最好是能让新人简单上手的，能日常使用的，懂个大概的；可能不是很官方术语，毕竟目标只是便于新手上路。\n基础概念 什么是 Git Git 是目前世界上最先进的分布式版本控制系统（没有之一）。\n先说什么是版本控制。举个例子来说，比如你拿到一个word文件，修改保存，修改再保存，再修改再保存，直到最后满意为止。版本控制就是可以随时查看并还原之前任意一次保存后的文件。\n版本控制系统常见的有两种，一种是 SVN 一种是 Git。那么他们两个有什么区别呢？区别在于git是分布式的版本控制系统。再举个例子，账房周先生那里有一本账，每位太太出去逛街后都需要去账房周先生那里登记，平时还好，几位太太基本都不会在账房碰面，毕竟谁也不想让别人说自己花销大。可是每当节日来临，比如中秋节啊，端午节啊之类的，几位太太就难免会碰面，然后发生冲突。这就是 SVN，集中式的，账房那本账一丢，就没有办法统计了。\n那什么是git呢？同样是账房周先生的这个例子，区别在与每位太太那里都有一本小帐，每次出去游玩后都可以先记在自己的小帐上，等有需要了再去账房周先生那里登记，这样就算账房那本账丢了，也无需太过与担心。\n示例图：\nSVN 工作流程图 Git 工作流程图\n什么是 Git-Flow Git-Flow是 Git 提交的规范，毕竟多个工程师开发同一个项目，如果不约定一个提交规范，那么基本不知道提交的是什么，还需要一点一点看提交变动的源码，这样做是很不方便的，所以Git 的提交规范应运而生，用的最多的就是Git-Flow。\n基本操作 Git的基本操作 生成 ssh 秘钥 1 2 3 4 cd ~/.ssh //查询文件夹是否存在，如果存在说明已经生成了ssh秘钥，跳过此步 ssh-keygen -t rsa -C \u0026#34;你公司内部/或者你自己的邮箱地址\u0026#34; //用来生成ssh 秘钥 复制公钥并添加到代码托管平台 1 cat id_rsa.pub //通过 `cat` 命令查看文件 `id_rsa.pub` 的内容，然后复制 以 Github 为例，如下图所示，进入 settings -\u0026gt; SSH and GPG keys 将复制的内容粘贴过来，点击 add ssh key，这一步等于说把你的公钥放到了 Github 上进行托管。\n全局配置用户名和邮箱 1 2 git config --global user.name \u0026#34;你的名字\u0026#34; git config --global user.email \u0026#34;你公司内部/或者你自己的邮箱地址\u0026#34; git init 初始化一个空仓库\n1 git init git add 添加文件到暂存区\n1 2 3 4 # 添加某个文件到暂存区，后面可以跟多个文件，以空格区分 git add xxx # 添加当前更改的所有文件到暂存区。 git add . git commit 提交更改\n1 2 3 4 5 6 7 8 # 提交暂存的更改，会新开编辑器进行编辑 git commit # 提交暂存的更改，并记录下备注 git commit -m \u0026#34;you message\u0026#34; # 等同于 git add . \u0026amp;\u0026amp; git commit -m git commit -am # 对最近一次的提交的信息进行修改,此操作会修改commit的hash值 git commit --amend git pull 推送代码到远程仓库\n1 2 3 4 # 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch \u0026amp;\u0026amp; git merge git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; # 使用rebase的模式进行合并 git pull --rebase \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; git fetch 与 git pull 不同的是 git fetch 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响\n1 2 3 4 # 获取远程仓库特定分支的更新 git fetch \u0026lt;远程主机名\u0026gt; \u0026lt;分支名\u0026gt; # 获取远程仓库所有分支的更新 git fetch --all git branch 分支相关操作\n1 2 3 4 5 6 7 8 9 10 11 12 # 新建本地分支，但不切换 git branch \u0026lt;branch-name\u0026gt; # 查看本地分支 git branch # 查看远程分支 git branch -r # 查看本地和远程分支 git branch -a # 删除本地分支 git branch -D \u0026lt;branch-nane\u0026gt; # 重新命名分支 git branch -m \u0026lt;old-branch-name\u0026gt; \u0026lt;new-branch-name\u0026gt; git-flow基本操作 git flow init 初始化\n1 2 3 4 5 6 7 8 9 10 11 已初始化空的 Git 仓库于 /Users/jouzeyu/test/.git/ No branches exist yet. Base branches must be created now. Branch name for production releases: [master] main //主分支名称，之前是master，现在用main多一些 Branch name for \u0026#34;next release\u0026#34; development: [develop] //开发分支名称，默认就好，下面无特殊要求都默认 How to name your supporting branch prefixes? Feature branches? [feature/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] 一些高的git版本中已经默认集成了git-flow，如果你的版本不支持，可以到github-\u0026gt;gitflow查看安装说明\ngit flow feature 开发一个新功能\n1 git flow feature start your-branch-name start后面一般跟你的新功能名称，它会基于develop 分支为基础创建的这个新的分支，当功能开发完成后，你可以运行：\n1 git flow feature finish your-branch-name 这条命令会将你新开发的功能合并到develop分支并删除该 feature 分支，然后切换回 develop 分支，当然，你可以通过命令git log查看操作历史。\ngit flow release 发布一个新版本\n1 git flow release start v0.0.1 新版本完成测试后就可以发布该分支了，你可以运行：\n1 git flow release finish v0.0.1 注意这个 release 版本的命名 我们一般习惯是 v+3 位数 因为这是一个新的项目还没有 tag 标签就从 0 开始了 那就是 v0.0.1 了 当然具体还是看公司规定\ngit flow hotfix 当我们出现 bug 需要修复又不想影响发布分支 可以新建一个 hotfix 分支来修复 bug，这个是基于master 分支帮我们创建的这个 hotfix 新分支：\n1 git flow hotfix start v0.0.1.1 当我们修复完毕后：\n1 git flow hotfix finish v0.0.1.1 他会在后面帮我们把分支合并到 master 然后打上标签 并删除该分支，同样，你也可以通过命令git log查看操作历史。\n注意这个命名版本号：我们一般习惯使用 v+4 位数来命名版本号 需要先查询最新的一个 release 分支因为 release 是 3 位的 在他的基础上加一位 因为我们上面刚刚完成的 release 版本号是 v0.0.1 所以我们新建的 hotfix 分支的名字就是 v0.0.1.1 eg: 如果我们 git tag 出的最新 release 为 v1.2.3 那我们的 hotfix 分支可以命名为 v1.2.3.1 以此类推\n工作中git解决问题场景 切换远程仓库地址 比如说，原先是github托管的代码，为了公司的代码安全，切换到了gitlab，那么远程仓库地址肯定是有变动的，你可以这样做：\n1 2 3 4 5 git remote -v //查看远程仓库地址 git remote rm origin //删除现有的仓库地址 git remote add origin url //url是新的仓库地址 使用 git stash 来暂存文件 很常见的情况就是你在开发新功能的时候，生产环境有个bug需要修改，这时你可以用 git stash 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。\n1 2 3 4 5 6 git stash //把本地的改动暂存起来 git stash save \u0026#34;message\u0026#34; 执行存储时，添加备注，方便查找。 git stash pop // 应用最近一次暂存的修改，并删除暂存的记录 git stash apply // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@{0}，如果要使用其他个，git stash apply stash@{$num} 。 git stash list // 查看 stash 有哪些存储 git stash clear // 删除所有缓存的 stash 使用 git alias 减少操作 你可以用git alias给一些命令配置别名，比如git commit=\u0026gt;git cm，你可以通过下面的命令进行配置： git config --global alias.\u0026lt;简化的字符\u0026gt; 原始命令\n其他待补充\n参考文献 我在工作中是如何使用 git 的\nGitFlow日常使用总结\n","permalink":"https://jouzeyu.com/posts/note_20220614/","summary":"不要让时代的悲哀，成为你的悲哀！","title":"Git 基本使用"},{"content":"laravel 9新增了很多新功能，下面要讲的这个功能就是其中之一。 如果你的 Controller 中有一些方法，但它们不遵循标准的 Resource 结构，您仍然可以对它们进行分组，而无需为每个方法重复 Controller 名称。 取而代之的是：\n1 2 3 Route::get(\u0026#39;profile\u0026#39;, [ProfileController::class, \u0026#39;getProfile\u0026#39;]); Route::put(\u0026#39;profile\u0026#39;, [ProfileController::class, \u0026#39;updateProfile\u0026#39;]); Route::delete(\u0026#39;profile\u0026#39;, [ProfileController::class, \u0026#39;deleteProfile\u0026#39;]); 您可以这样做：\n1 2 3 4 5 Route::controller(ProfileController::class)-\u0026gt;group(function() { Route::get(\u0026#39;profile\u0026#39;, \u0026#39;getProfile\u0026#39;); Route::put(\u0026#39;profile\u0026#39;, \u0026#39;updateProfile\u0026#39;); Route::delete(\u0026#39;profile\u0026#39;, \u0026#39;deleteProfile\u0026#39;); }); 此功能在 Laravel 9 和 Laravel 8 的最新小版本中可用。\n","permalink":"https://jouzeyu.com/posts/new_20220613/","summary":"不要让时代的悲哀，成为你的悲哀！","title":"Laravel 9 中的新功能： Route::controller ()"},{"content":"道可道，非常道；名可名，非常名。\n无名，天地之始，有名，万物之母。\n故常无欲，以观其妙，常有欲，以观其徼。\n此两者，同出而异名，同谓之玄，玄之又玄，众妙之门。\n","permalink":"https://jouzeyu.com/about/","summary":"关于本站","title":"关于网站"},{"content":"今天早上使用brew 安装东西的时候，没有安装成功，于是我先更新了一下brew ,返回了以下信息：\n1 2 3 4 Warning: No remote \u0026#39;origin\u0026#39; in /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core, skipping update! Warning: No remote \u0026#39;origin\u0026#39; in /usr/local/Homebrew/Library/Taps/homebrew/homebrew-services, skipping update! Warning: No remote \u0026#39;origin\u0026#39; in /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask, skipping update! Already up-to-date. 开始解决：\n1 2 3 4 5 6 rm -rf \u0026#34;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core\u0026#34; brew tap homebrew/core rm -rf \u0026#34;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-services\u0026#34; brew tap homebrew/services rm -rf \u0026#34;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask\u0026#34; brew tap homebrew/cask 再次运行brew update ，显示成功！ 再次运行原来的安装命令，成功！\n","permalink":"https://jouzeyu.com/posts/error_20220611/","summary":"不要让时代的悲哀，成为你的悲哀！","title":"Mac os 使用brew工具时报错No remote ‘origin‘"},{"content":"为什么现在年轻人普遍抑郁，双目无神？\n打个比方，牛羊在草地上快乐地吃草、散步、晒太阳，多开心啊。\n一旦他们发现自己只是食材，还能开心吗？\n智商是影响快乐的一大因素，你知道的越多越不快乐是肯定的。\n一旦你明白自己只是\u0026quot;栅栏里的一只羊\u0026quot;你还能开开心心的吃草才是怪事。\n你焦虑、抑郁是因为想要跳出去，却找不到方法。\n上面的话我是从别处看到的，我理解的有两个意思：\n我们焦虑是因为见识到了更广阔的世界，觉得我们渺小，觉得我们平凡，那为什么父母那一代人小时候就很少不焦虑呢？ 因为那时候互联网还不普及，他们的见识依赖于他们家庭本身，在相比较下，经常谈的就是谁谁谁家的孩子学习好，之类的， 感受到的差距很少，因为多数人都一样。不像现在你知道有很多很多，很多很多优秀的人，互联网让地球变成了一个地球村， 我们可能一直都在村里做比较，只不过这个村变大了不知多少倍。\n那么，我们就应该所谓的认命吗？我可以斩钉截铁的说，不是的！我们从来都不认命，在农村的时候，我们不就是不认“种地的”命吗？ 只不过因为我们知道的多了，想“升”的命的跨度变大了罢了。\n回归正题，我觉得焦虑是一个不服输的表现，如果你觉得实在累了，可以适当休息一会，也许我们不必和别人比，我们只要做好自己就可以了……\n","permalink":"https://jouzeyu.com/posts/life_20220610/","summary":"你所浪费的今天是昨天死去的人奢望的明天，你所厌恶的现在，是末来的你回不到的曾经","title":"你的焦虑是因为你还没有认命"},{"content":"我们先来看Laravel 8 的更新日志： 路由命名空间更新 在 Laravel 的早期版本中，RouteServiceProvider 具有 $namespace 属性。该属性的值将自动添加到控制器路由定义的前缀，并调用 action 助手函数或者 URL::action 方法。在 Laravel 8.x 中，默认情况下此属性为 null。这意味着 Laravel 不会自动命名空间前缀。因此，在新的 Laravel 8.x 应用程序中，应使用标准的 PHP 语法定义控制器路由：\n1 2 3 use App\\Http\\Controllers\\UserController; Route::get(\u0026#39;/users\u0026#39;, [UserController::class, \u0026#39;index\u0026#39;]); ok，了解了前置内容后，就容易多了，因为这一变动，我们经常碰见这种情况，例如，为不同的用户角色设置了 HomeController，例如 Admin/HomeController 和 User/HomeController。 如果在路由中使用完整路径，它看起来像这样：\n1 2 3 4 5 6 7 8 9 10 use App\\Http\\Controllers\\Admin\\HomeController; use App\\Http\\Controllers\\User\\HomeController; Route::prefix(\u0026#39;admin\u0026#39;)-\u0026gt;middleware(\u0026#39;is_admin\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [HomeController::class, \u0026#39;index\u0026#39;]); }); Route::prefix(\u0026#39;user\u0026#39;)-\u0026gt;middleware(\u0026#39;is_user\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [HomeController::class, \u0026#39;index\u0026#39;]); }); 这样有个问题，那就是分不清哪个是后台的控制器，当然我们可以设置别名，类似这样：\n1 2 3 4 5 6 7 8 9 10 use App\\Http\\Controllers\\Admin\\HomeController as AdminHomeController; use App\\Http\\Controllers\\User\\HomeController; Route::prefix(\u0026#39;admin\u0026#39;)-\u0026gt;middleware(\u0026#39;is_admin\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [AdminHomeController::class, \u0026#39;index\u0026#39;]); }); Route::prefix(\u0026#39;user\u0026#39;)-\u0026gt;middleware(\u0026#39;is_user\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [HomeController::class, \u0026#39;index\u0026#39;]); }); 但是，我觉得这样看起来更优雅：\n1 2 3 4 5 6 7 8 9 Route::prefix(\u0026#39;admin\u0026#39;)-\u0026gt;namespace(\u0026#39;App\\Http\\Controllers\\Admin\u0026#39;)-\u0026gt;middleware(\u0026#39;is_admin\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [HomeController::class, \u0026#39;index\u0026#39;]); // ... Admin 命名空间中的其他控制器 }); Route::prefix(\u0026#39;user\u0026#39;)-\u0026gt;namespace(\u0026#39;App\\Http\\Controllers\\User\u0026#39;)-\u0026gt;middleware(\u0026#39;is_user\u0026#39;)-\u0026gt;group(function () { Route::get(\u0026#39;home\u0026#39;, [HomeController::class, \u0026#39;index\u0026#39;]); // ... 来自用户命名空间的其他控制器 }); ","permalink":"https://jouzeyu.com/posts/distinguish-routing-files-by-namespace/","summary":"不要让时代的悲哀，成为你的悲哀！","title":"通过命名空间区分路由文件"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;?php use Illuminate\\Contracts\\Http\\Kernel; use Illuminate\\Http\\Request; define(\u0026#39;LARAVEL_START\u0026#39;, microtime(true)); /* |-------------------------------------------------------------------------- | Check If The Application Is Under Maintenance |-------------------------------------------------------------------------- | | If the application is in maintenance / demo mode via the \u0026#34;down\u0026#34; command | we will load this file so that any pre-rendered content can be shown | instead of starting the framework, which could cause an exception. | */ if (file_exists($maintenance = __DIR__.\u0026#39;/../storage/framework/maintenance.php\u0026#39;)) { require $maintenance; } /* |-------------------------------------------------------------------------- | Register The Auto Loader |-------------------------------------------------------------------------- | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We\u0026#39;ll simply require it | into the script here so we don\u0026#39;t need to manually load our classes. | */ require __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application\u0026#39;s HTTP kernel. Then, we will send the response back | to this client\u0026#39;s browser, allowing them to enjoy our application. | */ $app = require_once __DIR__.\u0026#39;/../bootstrap/app.php\u0026#39;; $kernel = $app-\u0026gt;make(Kernel::class); $response = $kernel-\u0026gt;handle( $request = Request::capture() )-\u0026gt;send(); $kernel-\u0026gt;terminate($request, $response); 整体逻辑 众所周知，代码是从上而下执行的，我们先大体了解下 laravel 的入口文件都做了什么事情，作者也是第一次分析源码，如有不足的地方敬请谅解。\n首先定义了一个 LARAVEL_START 的常量，值是浮点类型的当前 Unix 时间戳的微秒数-\u0026gt;接着检查应用程序是否在维护，也就是检查 storage/framework/maintenance.php 这个路径的文件是否存在-\u0026gt;接着加载 autoload、引入 bootstrap/app.php 直到跑起来；\n看到这里我们会有很多疑问，最起码我有很多疑问，比如一开始定义的常量有什么用？检查是否维护为什么要看 maintenance.php 存不存在？程序跑起来是怎么跑起来的？具体做了什么？\n我们往下看。\nLARAVEL_START 的意义 作为第一行代码，它的意义其实没有想象的那么高深，它的作用仅仅是为了记录程序开始时间，从而统计程序的总执行时间。（用截止时间 - 启动时间 = 程序执行时间），我们通常会说程序运行慢，不够快，那么是怎么得出来的？就是这么得出来的。\nlaravel 的维护模式 回到我们上面说的问题：检查是否维护为什么要看 maintenance.php 存不存在？我们运行 php artisan down 命令后会发现，在 storage/framework 下生成了两个文件，一个是 down,一个是 maintenance.php,这就是结果，你可以理解到这里，也可以继续往下深入，我想说的是，重要的不是结果，而是过程，同理，我主要会写我思考的过程，而不是我思考后发现的结果。\n首先，我们通过阅读官方文档后得知，laravel 的维护模式是通过 php artisan down 命令开始的，通过 php artisan up 命令结束的。然后，我们去找 php artisan down 这个命令做了什么东西，可以全局搜索 DownCommand 来找到我们需要的文件；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 \u0026lt;?php namespace Illuminate\\Foundation\\Console; use App\\Http\\Middleware\\PreventRequestsDuringMaintenance; use Exception; use Illuminate\\Console\\Command; use Illuminate\\Foundation\\Events\\MaintenanceModeEnabled; use Illuminate\\Foundation\\Exceptions\\RegisterErrorViewPaths; use Throwable; class DownCommand extends Command { /** * 定义控制台命令 * * @var string */ protected $signature = \u0026#39;down {--redirect= : The path that users should be redirected to} {--render= : The view that should be prerendered for display during maintenance mode} {--retry= : The number of seconds after which the request may be retried} {--refresh= : The number of seconds after which the browser may refresh} {--secret= : The secret phrase that may be used to bypass maintenance mode} {--status=503 : The status code that should be used when returning the maintenance mode response}\u0026#39;; /** * 命令标识 * * @var string|null */ protected static $defaultName = \u0026#39;down\u0026#39;; /** * 说明 * * @var string */ protected $description = \u0026#39;Put the application into maintenance / demo mode\u0026#39;; /** * 具体执行了那些内容 * * @return int */ public function handle() { try { //这里判断是否已经处于维护模式，如果是返回Application is already down. if ($this-\u0026gt;laravel-\u0026gt;maintenanceMode()-\u0026gt;active()) { $this-\u0026gt;comment(\u0026#39;Application is already down.\u0026#39;); return 0; } //创建down文件，写入getDownFilePayload()方法里面返回的数据 $this-\u0026gt;laravel-\u0026gt;maintenanceMode()-\u0026gt;activate($this-\u0026gt;getDownFilePayload()); //写入数据，就是创建maintenance.php文件，写入maintenance-mode.stub里面的数据 file_put_contents( storage_path(\u0026#39;framework/maintenance.php\u0026#39;), file_get_contents(__DIR__.\u0026#39;/stubs/maintenance-mode.stub\u0026#39;) ); //开启事件 $this-\u0026gt;laravel-\u0026gt;get(\u0026#39;events\u0026#39;)-\u0026gt;dispatch(MaintenanceModeEnabled::class); //输出提示语 $this-\u0026gt;comment(\u0026#39;Application is now in maintenance mode.\u0026#39;); } catch (Exception $e) { $this-\u0026gt;error(\u0026#39;Failed to enter maintenance mode.\u0026#39;); $this-\u0026gt;error($e-\u0026gt;getMessage()); return 1; } } /** * Get the payload to be placed in the \u0026#34;down\u0026#34; file. * * @return array */ protected function getDownFilePayload() { return [ \u0026#39;except\u0026#39; =\u0026gt; $this-\u0026gt;excludedPaths(), \u0026#39;redirect\u0026#39; =\u0026gt; $this-\u0026gt;redirectPath(), \u0026#39;retry\u0026#39; =\u0026gt; $this-\u0026gt;getRetryTime(), \u0026#39;refresh\u0026#39; =\u0026gt; $this-\u0026gt;option(\u0026#39;refresh\u0026#39;), \u0026#39;secret\u0026#39; =\u0026gt; $this-\u0026gt;option(\u0026#39;secret\u0026#39;), \u0026#39;status\u0026#39; =\u0026gt; (int) $this-\u0026gt;option(\u0026#39;status\u0026#39;, 503), \u0026#39;template\u0026#39; =\u0026gt; $this-\u0026gt;option(\u0026#39;render\u0026#39;) ? $this-\u0026gt;prerenderView() : null, ]; } /** * Get the paths that should be excluded from maintenance mode. * * @return array */ protected function excludedPaths() { try { return $this-\u0026gt;laravel-\u0026gt;make(PreventRequestsDuringMaintenance::class)-\u0026gt;getExcludedPaths(); } catch (Throwable $e) { return []; } } /** * Get the path that users should be redirected to. * * @return string */ protected function redirectPath() { if ($this-\u0026gt;option(\u0026#39;redirect\u0026#39;) \u0026amp;\u0026amp; $this-\u0026gt;option(\u0026#39;redirect\u0026#39;) !== \u0026#39;/\u0026#39;) { return \u0026#39;/\u0026#39;.trim($this-\u0026gt;option(\u0026#39;redirect\u0026#39;), \u0026#39;/\u0026#39;); } return $this-\u0026gt;option(\u0026#39;redirect\u0026#39;); } /** * Prerender the specified view so that it can be rendered even before loading Composer. * * @return string */ protected function prerenderView() { (new RegisterErrorViewPaths)(); return view($this-\u0026gt;option(\u0026#39;render\u0026#39;), [ \u0026#39;retryAfter\u0026#39; =\u0026gt; $this-\u0026gt;option(\u0026#39;retry\u0026#39;), ])-\u0026gt;render(); } /** * Get the number of seconds the client should wait before retrying their request. * * @return int|null */ protected function getRetryTime() { $retry = $this-\u0026gt;option(\u0026#39;retry\u0026#39;); return is_numeric($retry) \u0026amp;\u0026amp; $retry \u0026gt; 0 ? (int) $retry : null; } } 跑起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //引入Composer注册自动加载程序, Laravel的自动类文件自动加载等功能都是通过Composer来实现的 require __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; //引入核心应用类, 主要是实现核心类库加载以及Laravel框架中核心的服务容器注册加载等 $app = require_once __DIR__.\u0026#39;/../bootstrap/app.php\u0026#39;; //获取在app.php中已经注册的Kernel $kernel = $app-\u0026gt;make(Illuminate\\Contracts\\Http\\Kernel::class); //容器中绑定的Kernel是App\\Http下的，该类继承了Illuminate\\Foundation\\Http下的Kernel，这里调用的就是父类的handle方法 //主要实现的功能是通过管道实现中间件及路由分发执行 $response = $kernel-\u0026gt;handle( //创建request实例 $request = Request::capture() )-\u0026gt;send();//响应请求 //响应中间件 $kernel-\u0026gt;terminate($request, $response); ","permalink":"https://jouzeyu.com/posts/laravel-parsing-entry-file/","summary":"所谓成长，不一定得到了什么，但肯定失去了什么……","title":"Laravel解析-入口文件"},{"content":" mysql 的请求流程为客户端发起请求，进入链接层，这里会进行 mysql 用户密码及权限认证，然后去查询缓存，缓存没有的话通过解析器，优化器查询数据并返回，这里做不做缓存？\n锁机制，从锁粒度来分有表锁，行锁，页锁，从使用方式来分有共享锁和排它锁，其实就是读锁和写锁，从思想上分有乐观锁和悲观锁。\n表锁的话就是锁定整张表，一个用户要写入数据时，需要先获取写锁，这个时候其他用户不能读或者写数据，只有没有锁的时候才能获取读锁。\n行级锁是在存储引擎中实现的，最常用的有 innodb，它不在服务器层实现。\n事务就是一组原子性的 sql 查询，或者说是第一独立的工作单元，说到原子性就不得不说一下 acid，即原子性，一致性，隔离性，持久性。原子性简单来说就是要不全部成功，要不全部失败然后回滚，一致性呢就是从一个一致性的状态转换到另外一个一致性的状态，隔离性的意思是该事务在提交前对其他事务是不可见的，持久性就是当事务提交后，事务所做的修改就被持久储存了下来，就算系统崩溃，被修改的数据也被存储了下来；\n隔离级别在 sql 标准中定义了四个，通常来说，越低的隔离级别代表可以支持更高的并发及更低的系统开销。说到四个隔离级别，分别是未提交读，已提交读，可重复读，可串行化。mysql 的默认隔离级别是可重复读。未提交读的含义就是说我事务还没提交的数据其他事务也是可见的，就像是我打算跳槽，还没跳，其他同事就知道了，这样会遭成脏读，可以理解成我最终没跳，但其他同事以为我跳了，情况不一致；已提交读是大多数数据库的隔离级别，但不是 mysql 的。这个级别的含义就是，一个事务开始时，只能看见已经提交的事务所做的修改，可以理解成别的同事要了解我的在职状态只有我确定离职了才知道，这个级别也叫做不可重复读，因为有时候两次同样的查询，结果是不一样的；可重复读可以解决脏读的问题，但它又有可能造成一个新的问题，幻读，啥意思呢，就是说一个事务在读取某个范围的数据的时候，另外一个事务在这个范围内插入了新的数据，当之前的事务再次读这个范围的数据的时候会产生幻行。innodb 通过 mvcc 解决了幻读的问题，**那么什么是 mvcc？**可串行化是最高的隔离级别，它解决了上面说的幻读的问题，当然也不会出现脏读，因为它会在每一行读取的数据上加锁，鱼和熊掌不可兼得，当然它的锁开销就很大，容易造成大量超时和锁争用的问题，实际也很少用这个隔离级别。那么总结下就是未提交读容易造成脏读，不可重复读，幻读，不加锁，可串行化这三个读都不造成，但加锁，mysql 默认的隔离级别容易造成幻读，但是通过 mvcc 处理了，已提交读容易造成不可重复读和幻读。\n说到锁，就不得不说一下死锁。死锁是指两个或多个事务在同一资源上互相占用，并请求锁定对方占用资源，从而导致恶性循环的现象。针对这一情况，数据库系统实现了各种死锁检测和死锁超时机制。通常解决方法有两种，一种就是 innodb 这类通过检测死锁的循环依赖，返回一个错误，另外一种就是当查询等待超时的时候，放弃锁请求，这种方法不太推荐。目前 innodb 的死锁处理方式是，将持有最少行级排他锁的事务进行回滚，这是相对简单的死锁回滚算法。\n再来说锁，锁的行为和顺序是和存储引擎相关的，相同的顺序执行语句，不同的引擎，有的会产生死锁，有的不会（这里没再往深研究）；死锁的产生原因有两种，一种是真的数据冲突，另外一种是因为存储引擎的实现方式导致的，一般情况下，产生死锁后，回滚部分事务，然后重新执行被回滚的事务即可；\n事务日志可以帮助提高事务的效率，每次修改数据的时候，只需要修改内存拷贝，再把这一行为记录在事务日志中，然后在后台会慢慢写进硬盘中，而不用每次都在硬盘中修改。事务日志是追加的方式，所以在内存中是顺序 io，而不是随机 io，从而要快的多。\n事务的自动提交，mysql 默认是自动提交的模式，可以通过 autocommit 设置是否关闭，1 ｜ on 是启用，0 ｜ off 是禁用。如果不是显式地开始一个事务，则每个查询都会当作一个事务执行提交操作。（建议再看看显式和隐式锁定这部分）\n在一个事务中尽量不要混合使用存储引擎。首先我们知道一点，事务是下层的存储引擎决定的，和 mysql 的服务器层没关系，如果我们混合使用的事务中有一个事务型表和一个非事务型表，正常情况是没问题的，但回滚的时候，事务型表回滚来，非事务型表不会回滚，而且这种情况很难修复，事务的最终结果无法确定。\n接下来说说之前提到的 mvcc，mvcc 可以看作行级锁的一个变种，它减少了很多情况下的加锁操作，从而减少锁开销，它实现了非阻塞的读操作，写操作也只是锁定必要的行。它是通过保存数据在某个时间点的快照实现的。简单讲 innodb 的 mvcc 就是每行记录后面保存了两个列，一个是创建时间，一个是过期/删除时间，当然也不是真的时间，是系统版本号，没新开一个事务，版本号就会递增，用事务开始时候的版本号和查询到的版本号做比较。（简单说了下）\n新概念：间隙锁，它的作用是防止幻读的产生。它不仅锁定了查询所涉及到的行，还对索引中的间隙进行了锁定，以防止幻影行的插入。\n","permalink":"https://jouzeyu.com/posts/mysql-study-notes/","summary":"手上没有剑，和有剑不用，是两码事","title":"Mysql 学习笔记"},{"content":"前言 面向对象编程是我们接触编程过程中很早就接触到的概念。还记得刚上大学的时候，老师给我们讲了面向对象的三个特性封装、继承、多态，并实际用代码展示了他们的外在表现形式。后来就是代码实操了，再往后，工作一年半多了才真正意义上想要去了解这一思想，开始恶补面向对象编程思想、设计模式等等。接下来是我自己的面向对象这一思想的浅谈，供其他人参考。\n什么是面向对象编程 首先我引用一句别人说过的话：“程序的一切功能，都是调用加封装的结果。”调用什么呢？调用的是对象；封装什么呢？封装的也是对象。无论早期的编程还是现在的编程，都是围绕对象来编程的。\n接下来我们来说说面向对象的发展史。以时间顺序，按照大类来分，可以分为汇编语言-\u0026gt;C语言-\u0026gt;其他语言（PHP、C++、Java等）。上面我们说到，我们是围绕对象来编程的，但是对象的界定方式又有所不同，比如我们可以说人是由身体和灵魂构成的，也可以说人是由头、躯干、四肢构成的，角度不同，对事物的定界定也不同。我们再回头看发展史，其实就是由面向计算机视角的编程转变为面向人视角的编程的发展过程。\n一开始的时候，对象是在计算机视角定义的，在机器眼中CPU上的电路、内存上的电路就是一个个对象，我们通常说的机器指令就是这些电路，我们用一串二进制的数来表示这些指令，也就是说在机器眼中这一串数就是对象，所以机器调用和封装的就是像这样比较底层的对象。汇编语言就是用单词代表这些二进制的数，从本质上看换汤不换药，这也是汇编语言一直健在的原因；后来C语言出世，它不是在机器的视角界定的对象，也不是从人的视角界定的对象，在它的眼中，对象就是数据和算法，这对人们来说，要比汇编语言直观的多，但C语言的底层还是机器语言，只不过把机器语言进行来封装，用C语言的语法来封装和调度；讲到这里，我们可以看出，C语言其实还是偏向计算机视角来界定对象，人们当然希望能够完全从人的视角去界定对象，而完全从人的视角界定对象的编程就是我们通常说的面向对象编程。我们把数据和算法结合起来，就是面向对象编程的对象，可以看到在C语言中，数据和算法是分开的。\n为什么要采用面向对象编程 很简单，解决问题更容易，毕竟设计计算机程序就是为了解决人类的问题。这里有个叫做“动态编程”的过程，这是一个将大问题，拆分成一个个小问题的技术。其策略就是先解决这些小问题，然后把所有结果汇总起来形成一个更大的解决方案。有点类似工厂里面的流水线，先把各个小部件制造出来，最后加工组合成一个完整的产品。\n拆分小问题的过程就是模块化。\n类和对象 我们把一个问题模块化后，该怎么处理这些模块呢？我们常用的做法就是把一个模块看作是相关函数的一个集合。在编程中，我们把这些模块称为类，类又两部分组成，属性和方法。属性就是不同类型的数据对象，比如数字，字符串，null。通常数据作为抽象数据类型存储，比如存储为变量、常量、数组；方法就是处理这些数据的函数。\n抽象 我们在谈到面向对象的三大特性之前，需要先了解抽象。\n什么是抽象？OOP和设计模式的先驱给了一个明确的定义：“抽象指示一个对象的基本特征，使它与所有其他对象区分开，从而从查看者的角度提供了清晰定义的概念边界。”简单说就是对对象进行分组和分类，比如忠实的，毛茸茸的、摇尾巴的、爱舔来舔去的、湿鼻子的我们称之为狗，狗就是一个对具体的相似性的抽象。\n除了常规的类，PHP提供了抽象类。抽象类不能实例化，只能由具体类继承抽象类的接口及它的所有具体属性。其实很好理解，抽象类就相当于提出了定义狗的特征，我们在它的基础上进行判断，金毛是狗，哈士奇是狗，但不能说狗是什么，狗是一个概念，不是具体指某个动物，而是某类动物。\n如果一个类至少有一个抽象方法，它必然是一个抽象类。上面我们说过，函数就是方法，要写一个抽象函数，可以用abstract关键字来声明，它可以只包含接口，不包括其他任何内容，如：\n1 abstract public function test($number); 如果一个抽象类声明来一个抽象方法，那么继承这个父类的各个子类都必须实现这个方法。\n封装 说到封装，可能大家都不陌生，我用现实的例子可能更好理解这一概念。就像是一辆汽车，它由很多对象构成，发动机、内燃机、电力系统等等，可是我们需要都了解吗？我们要启动车只需要打火就可以了，并不需要了解在你打火时汽车都做了什么，这就是封装。车子打火后就能启动，你并不知道它具体做了哪些事情，这就是信息隐藏。\n通过可见性保护封装。为什么要保护封装？比如你正常开车行驶，有一辆车接近你，你开着窗，他伸手抢你的方向盘，这就影响了你的开车，我们称之为破坏封装，所以我们需要摇起车窗，来保护我们的“封装”不被破坏。回到正题，可见性是指对类属性的存取或访问。PHP有三种可见性：private(私有)、protected(受保护)、public(公共)。\n私有，就是说明这个属性只能在同一类中使用，它仅对这个类中的元素可见，继承它的类或者其他类都不能读取。\n受保护，就是说明这个属性只能在同一类或者继承它的类中读取，对其他类不可操作。 公共，顾名思义，就是说明大家都可以读取。\n要封装一个程序元素，最好的方法是设置为私有，但是要访问封装对象，必须提供公共可见性，总不能用车的时候，连打火都不让吧。\n继承 继承是一个简单的概念，一个类如果拓展类另外一个类，就会拥有这个类的所有属性和方法。被继承的类叫做父类，继承了其他类的新类叫做子类。举个例子：有个父类中有个test函数，子类中就可以调用这个test函数，如果不满意父类中test函数实现的功能，修改类部分代码，这就叫做重写。\n当然，你可以在继承父类的基础上调用父类的方法，同样也可以写新的方法。\n多态 多态就是指多种形态。它的基础是继承，也就是说要实现多态，就必然涉及到继承。那么，怎么去理解多态呢？\n举个例子，我们声明了一个名为dog的接口，定义了一个叫name的函数。一个类继承了这个接口，name函数返回了哈士奇，另外一个类也继承了这个接口，返回了金毛。同一个函数，返回了不同的名字，这就是多态。\n后记 面向对象编程这一思想，并不是一下就能理解的，它需要我们花时间和精力去慢慢了解，上面讲述的只是一些简单的概念，在今后的学习中相信我们将能更深刻理解。\n","permalink":"https://jouzeyu.com/posts/php-and-object-oriented-programming/","summary":"我不追逐影子，影子自然随我～","title":"PHP与面向对象编程浅谈"},{"content":"前言 最近在网上有个真实发生的案例比较火，说的是一个新入职的员工，不会用 Git 拉代码，第二天被开除。由此，可见 Git 对我们工作的重要性，无论是前端后端，都是离不开 Git 的，下面就让我们一探究竟吧。\n上面的案例引申出一个问题，入职一家新公司，你的 leader 给你分配了仓库的权限后，如何配置本地的 Git 环境并拉取代码？莫慌，按照下面我讲的四个步骤走，保证你可以顺利使用 Git 进行拉取代码！\n下载 Git 下载地址 ，选择自己系统对应的版本下载即可。\n在你的电脑上生成 ssh 秘钥，打开终端，执行 ssh-keygen -t rsa -C \u0026quot;你公司内部邮箱地址\u0026quot;，如果执行成功，切换到 ~/.ssh 目录下，此时目录应该如下所示。复制 id_rsa.pub 的内容。\n这里以 Github 为例，如下图所示，进入 settings -\u0026gt; SSH and GPG keys 通过 cat 命令查看文件 id_rsa.pub 的内容，然后复制过来，点击 add ssh key，这一步等于说把你的公钥放到了 Github 上进行托管。\n全局配置 Git 的用户名和邮箱\n1 2 3 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@xx.com\u0026#34; 复制代码 完成以上四步，你就可以愉快 pull 代码开发了。和 https 拉取方式不同的是，https 方式需要每次提交前都手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。\nGit 简介 在介绍 Git 的相关操作前，我觉得非常有必要了解 Git 的由来，以及 Git 是用来解决什么问题的。Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Linus Torvalds ，这个人我相信大家都知道吧，开源 Linux 系统的发明人。如今，你看到的大部分服务器其实都是运行在 Linux 系统上，令人感到称叹的是，这位大神级别的程序员不仅创造了 Linux 系统。那 Linux 的代码是如何管理的呢？2002 年之前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！要知道，当时的 Linux 的代码量已经很大了，通过人工管理的方式，一是容易出错，二是效率低。于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。最后，出于某种原因，BitMover 公司收回了 Linux 社区的免费使用权，于是 Linus 花了两周时间自己用 C 语言 写了一个分布式版本控制系统，这就是 Git 的由来了。\nGit 的工作区域和流程 要想弄懂 Git 是怎么对我们的代码进行管理的，那首当其冲的是了解 Git 的工作区域是如何构成的。因为，只有彻底弄懂了 Git 工作区域的构成，你才可以在适当的区域使用合适的命令。如下图所示，此图包含了 Git 的 4 个工作区和一些常见的操作。\nWorkspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作\nIndex：暂存区，当执行 git add 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 git add 先提交到暂存区。\nRepository：本地仓库，位于自己的电脑上，通过 git commit 提交暂存区的内容，会进入本地仓库。\nRemote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 git push 命令同步代码到远程仓库。\n一般来说，Git 的工作流程分为以下几步\n1 2 3 4 5 1.在工作区开发，添加，修改文件。 2.将修改后的文件放入暂存区。 3.将暂存区域的文件提交到本地仓库。 4.将本地仓库的修改推送到远程仓库。 复制代码 Git 基本操作 git add 添加文件到暂存区\n1 2 3 4 5 # 添加某个文件到暂存区，后面可以跟多个文件，以空格区分 git add xxx # 添加当前更改的所有文件到暂存区。 git add . 复制代码 git commit 1 2 3 4 5 6 7 8 9 # 提交暂存的更改，会新开编辑器进行编辑 git commit # 提交暂存的更改，并记录下备注 git commit -m \u0026#34;you message\u0026#34; # 等同于 git add . \u0026amp;\u0026amp; git commit -m git commit -am # 对最近一次的提交的信息进行修改,此操作会修改commit的hash值 git commit --amend 复制代码 git pull 1 2 3 4 5 # 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch \u0026amp;\u0026amp; git merge git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; # 使用rebase的模式进行合并 git pull --rebase \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 复制代码 git fetch 与 git pull 不同的是 git fetch 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响\n1 2 3 4 5 # 获取远程仓库特定分支的更新 git fetch \u0026lt;远程主机名\u0026gt; \u0026lt;分支名\u0026gt; # 获取远程仓库所有分支的更新 git fetch --all 复制代码 git branch 1 2 3 4 5 6 7 8 9 10 11 12 13 # 新建本地分支，但不切换 git branch \u0026lt;branch-name\u0026gt; # 查看本地分支 git branch # 查看远程分支 git branch -r # 查看本地和远程分支 git branch -a # 删除本地分支 git branch -D \u0026lt;branch-nane\u0026gt; # 重新命名分支 git branch -m \u0026lt;old-branch-name\u0026gt; \u0026lt;new-branch-name\u0026gt; 复制代码 工作中使用 Git 解决问题的场景 git rebase 让你的提交记录更加清晰可读 git rebase 的使用 rebase 翻译为变基，他的作用和 merge 很相似，用于把一个分支的修改合并到当前分支上。\n如下图所示，下图介绍了经过 rebase 后提交历史的变化情况。\n现在我们来用一个例子来解释一下上面的过程。\n假设我们现在有 2 条分支，一个为 master，一个为 feature/1，他们都基于初始的一个提交 add readme 进行检出分支，之后，master 分支增加了 3.js 和 4.js 的文件，分别进行了 2 次提交，feature/1 也增加了 1.js 和 2.js 的文件，分别对应以下 2 条提交记录。\n此时，对应分支的提交记录如下。\nmaster 分支如下图：\nfeature/1 分支如下图\n结合起来看是这样的\n此时，切换到 feature/1 分支下，执行 git rebase master，成功之后，通过 git log 查看记录。\n如下图所示：可以看到先是逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature/1 的每个更改。\n所以，我们的提交记录就会非常清晰，没有分叉，上面演示的是比较顺利的情况，但是大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 git add 、git rebase --continue 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 git rebase --skip 来跳过这次 rebase 操作。\ngit merge 和 git rebase 的区别 不同于 git rebase 的是，git merge 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 Merge branch 'xxx' into 'xxx' 的一条提交信息。\n另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。\ngit rebase 交互模式 在开发中，常会遇到在一个分支上产生了很多的无效的提交，这种情况下使用 rebase 的交互式模式可以把已经发生的多次提交压缩成一次提交，得到了一个干净的提交历史，例如某个分支的提交历史情况如下：\n进入交互式模式的方式是执行：\n1 2 git rebase -i \u0026lt;base-commit\u0026gt; 复制代码 参数 base-commit 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作，对于上述提交历史的例子，我们要把最后的一个提交对象（ ac18084 ）之前的提交压缩成一次提交，我们需要执行的命令格式是：\n1 2 git rebase -i ac18084 复制代码 此时会进入一个 vim 的交互式页面，编辑器列出的信息像下列这样。\n想要合并这一堆更改，我们要使用 Squash 策略进行合并，即把当前的 commit 和它的上一个 commit 内容进行合并， 大概可以表示为下面这样，在交互模式的 rebase 下，至少保留一个 pick，否则命令会执行失败。\n1 2 3 4 5 pick ... ... s ... ... s ... ... s ... ... 复制代码 修改文件后 按下 : 然后 wq 保存退出，此时又会弹出一个编辑页面，这个页面是用来编辑提交的信息，修改为 feat: 更正，最后保存一下，接着使用 git branch 查看提交的 commit 信息，rebase 后的提交记录如下图所示，是不是清爽了很多？rebase 操作可以让我们的提交历史变得更加清晰。\n特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。\n使用 git cherry-pick 获取指定的 commit git cherry-pick 可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 git cherry-pick 了。\n如下场景，以下有三条分支，feature/cherry-pick1 和 feature/cherry-pick2 都是基于 master 检出的两条功能性分支，对应的分支 log 记录如下\nmaster 分支的提交如下 现在 master 只需要 feature/cherry-pick1 和 feature/cherry-pick2 有关 change 的修改，并不关心有关 fix 内容的修改。此时就可以用 cherry-pick 指令了。\n语法： git cherry-pick [commit-hash]\ncommit-hash 表示的是某次 commit 的 hash 值。现在，依次执行以下两条指令 git cherry-pick e0bb7f3、git cherry-pick c9a3101，过程中，如果出现冲突，解决冲突后 进行 git add ，接着执行 git cherry-pick --continue，最后，master 上的提交如下\n此时，master 分支上应用了需要的提交，就达到了我们想要的效果。如果需要多个 cherry-pick 需要同步到目标分支，可以简写为 git cherry-pick \u0026lt;first-commit-id\u0026gt;...\u0026lt;last-commit-id\u0026gt;，这是一个左开右闭的区间，也就时说 first-commit-id 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用 git cherry-pick \u0026lt;first-commit-id\u0026gt;^...\u0026lt;last-commit-id\u0026gt;，它表示包含 first-commit-id 到 last-commit-id 在内的提交都会被合并过去。\n使用 git revert 回滚某次的提交 想象这么一个场景，你的项目最近有 2 个版本要上线，这两个版本还伴随着之前遗留的 bug 的修复，一开始的时候，你将 bug 修复在了第一个版本的 release 分支上，突然在发版前一天，测试那边反馈，需要把第一个版本修复 bug 的内容改在第二个版本上，这个时候，第一个版本的集成分支的提交应该包括了第一个版本的功能内容，遗留 bug 修复的提交和其他同事提交的内容，想要通过 reset 的方式粗暴摘除之前的关于 bug 修复的 commit 肯定是不行的，同时，这种做法比较危险，此时，我们既不想破坏之前的提交记录，又想撤回我们遗留 bug 的 commit 记录应该怎么做呢？git revert 就派上了用场。\ngit revert 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。\n语法： git revert \u0026lt;commit-id\u0026gt; 针对普通 commit\ngit revert \u0026lt;commit-id\u0026gt; -m 针对 merge 的 commit\n下面就用一个案例来理解一下这个命令，如下图所示，假设被红框框起来的地方是会引起 bug 的一次提交，在他的提交之后，又进行了 2 次提交，其中包含了其它同事的提交。\n此时想把引起提交的 bug 的干掉，执行 git revert 1121932，执行操作后，再打开查看日志，如下图所示，可以看到是新增了一条 commit 记录，这个 commit 的产生的 msg 是自动生成的，Revert 开头，后面跟撤回的 commit-msg 信息 之前的 commit 记录并没有消失，此时也达到了代码回退的效果\n此外 git revert 也可以回滚多次的提交\n语法：git revert [commit-id1] [commit-id2] ... 注意这是一个前开后闭区间，即不包括 commit1 ，但包括 commit2 。\n回滚我们的提交有二种方式，一种是上文提到的git revert命令外，还可以使用 git reset 命令，那么它们两者有什么区别呢？\ngit revert 会新建一条 commit 信息，来撤回之前的修改。\ngit reset 会直接将提交记录退回到指定的 commit 上。\n对于个人的 feature 分支而言，可以使用 git reset 来回退历史记录，之后使用 git push --force 进行推送到远程，但是如果是在多人协作的集成分支上，不推荐直接使用 git reset 命令，而是使用更加安全的 git revert 命令进行撤回提交。这样，提交的历史记录不会被抹去，可以安全的进行撤回。\n使用 git stash 来暂存文件 会有这么一个场景，现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 git stash 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。\n基本命令如下\n1 2 3 4 5 6 7 git stash //把本地的改动暂存起来 git stash save \u0026#34;message\u0026#34; 执行存储时，添加备注，方便查找。 git stash pop // 应用最近一次暂存的修改，并删除暂存的记录 git stash apply // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@{0}，如果要使用其他个，git stash apply stash@{$num} 。 git stash list // 查看 stash 有哪些存储 git stash clear // 删除所有缓存的 stash 复制代码 下面通过几幅图对 stash 的命令做进一步了解。\n此时，我正在开发一个新功能，修改了 1.js 文件里的内容\n还没开发完成，这个时候，我想切换到 hotfix 分支上修复 bug，得暂停下开发切换到 hotfix 分支，但是现在工作区还有内容，此时如果切换分支 Git 会报出下面的错误\n1 2 3 4 5 error: Your local changes to the following files would be overwritten by checkout: 1.js Please commit your changes or stash them before you switch branches. Aborting 复制代码 上面那句话的意思就是说工作区有文件修改，不能提交，需要先进行 commit 或者 stash 操作，执行 git stash，结果如下\n1 2 Saved working directory and index state WIP on stash: 22e561c feat: add 1.js 复制代码 此时，我们的工作区已经干净了，可以切换到 hotfix 分支进行 bug 修复的工作，假设我们现在 bug 修复完成了，继续切回 feature 分支进行原本功能的开发，此时只需要执行 git stash pop，之前我们暂存的修改就会恢复到工作区，如下图所示。\n当我们想要暂存文件，切换分支做某些事的时候，可以用 git stash 这种机制帮助开发。\n推荐在使用 stash 的相关命令时，每一次暂存的时候，不要直接使用 git stash 命令进行暂存下来，而是使用 git stash save \u0026quot;message...\u0026quot; 这种方式，给本次的提交做一个信息的记录。这样，想应用更改的时候，先通过 git stash list 查看一下所有的暂存列表。之后，推荐使用 git stash apply stash@${num} 的方式进行应用对应的 stash，这样不会清空已有的 stash 的列表项，并且能应用到当前的工作区，不需要这个暂存的话，再手动清除就可以了。\n不同的工作区域撤销更改 开发中，我们经常需要回退代码的操作，在不同的工作区域中，回退代码的方式也是不相同的。如下图所示，假设现在要在 feature/revoke 分支上进行开发,\n首先通过 git status 查看下现在的状态。\n目前我们的工作区是很干净的，没有任何修改的操作，此时，修改一下代码再次查看状态，可以看到，1.js 这个文件被修改了。\n现在我们想把 1.js 这个文件恢复到修改前的状态，即撤回工作区的修改，就可以使用 git checkout -- \u0026lt;filename\u0026gt; 的命令，如果要撤回多个文件的修改，文件之间使用空格隔开，如下图所示，我们撤回了 1.js 文件的修改，工作区也恢复干净了。\n如果说现在我们对文件进行了修改，并且已经提交到暂存区了，这部分文件我们不想要的话，那么就可以通过 git reset \u0026lt;filename\u0026gt; 的命令来对特定的文件进行撤销，git reset 会撤回所有存在暂存区的文件，如下图所示，查看前后的状态可知，文件最后成功撤回到工作区了。\n配置 git alias 提升工作效率 一般我们在工作中，接到开发任务后，需要新创建一个分支进行开发 此时需要 用到 git branch、git checkout、 git pull 等命令，在我们一顿操作后，开发完成，到了提交代码的阶段，又要诸如此类 git add 、git commit、git push 等命令，虽然简单，但是输入起来也是不够简洁，作为一个程序员，开发程序就是为了提高我们的效率的，懒是人类进步的源泉，所以我们可以通过配置别名的方式，简化这些命令。\n它的基本用法是 git config --global alias.\u0026lt;简化的字符\u0026gt; 原始命令\n如下面的例子：\n1 2 3 4 $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 复制代码 这里将 co 表示 checkout，ci 表示 commit，br 表示 branch，以后提交就可以简写成\n--global 是全局参数，也就是配置一次后，这些命令可以在这台电脑下的所有仓库都适用。这些命令其实是更新你全局的 .gitconfig 文件，该文件用来保存全局的 git 配置，vim ~/.gitconfig，执行这段命令后，显示如下，下图展示了刚才通过 git config --global alias 添加的 alias。\n除了上面那种直接通过命令的方式外，也可以通过修改这个文件的 alias 项来设置别名。\n这里分享一个我自己常用的别名设置，把以下配置替换到 .gitconfig 文件里的 [alias] 所属的区域，然后就可以愉快的使用了~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [alias] st = status -sb co = checkout br = branch mg = merge ci = commit ds = diff --staged dt = difftool mt = mergetool last = log -1 HEAD latest = for-each-ref --sort=-committerdate --format=\\\u0026#34;%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\\\u0026#34; ls = log --pretty=format:\\\u0026#34;%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\\\u0026#34; --decorate --date=short hist = log --pretty=format:\\\u0026#34;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\\\u0026#34; --topo-order --graph --date=short type = cat-file -t dump = cat-file -p lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit 复制代码 这样，我们每次想查看 Git 的历史记录,就不用输入那么一长串命令 直接使用 git lg ，下图是 axios 源码里的提交记录，使用封装后的 git lg 查看的效果图\n分支之间的关系一眼就很明了，在哪个 commit 上进行的 merge 操作也很清晰，可以帮助我们很好的追溯历史的提交和解决问题。\n总结 本文由浅入深的的讲解了 Git 的环境搭建，基本用法，以及工作中使用较为高频的 Git 命令的用法，无论你是前端后端还是其它端的开发，日常工作中少不了对 Git 的使用，我们不仅要会用，还要用的漂亮，用的灵活，用的稳健。这样才能在和同事协作项目的时候更加得心应手，学会了本文这些 Git 的使用技巧后，在日常工作中多多练习，相信会给你带来很大的收获！\n作者：政采云前端团队 链接：https://juejin.cn/post/6974184935804534815 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","permalink":"https://jouzeyu.com/posts/work-with-git/","summary":"不要让时代的悲哀，成为你的悲哀！","title":"「转载」我在工作中是如何使用 Git 的"},{"content":"效果图预览：\n大家好，最近重搭了个人博客，之前用 Hexo，WordPress 也搭建过，但是总是很不理想，最近用 hugo 感觉还不错，接下来将我搭建的过程记录下来，方便大家自己尝试；\n本地搭建 因为我用的是 MacBook，所以接下来也将基于此环境做演示；\n安装 hugo 1 2 brew install hugo #安装hugo hugo version #查看版本 这里注意下，安装的是拓展版本，方便以后做拓展，如何查看自己安装的是不是拓展版本，hugo v0.89.2+extended darwin/amd64 BuildDate=unknown查看版本显示这个就是拓展版本（带 extended 的）；\n新建站点 1 hugo new site site-name #自行定义站点名 添加主题 1 2 3 4 cd site-name #切换到站点根目录 git init #初始化git仓库 git clone https://github.com/dillonzq/LoveIt.git ./themes #这里我安装的是LoveIt主题 cp themes/loveit/exampleSite/config.toml ./config.toml #直接将主题的配置文件复制过来替换成站点配置 站点配置 设置站点默认语言 1 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; 禁用主题目录 1 #themesDir = \u0026#34;../../\u0026#34; 设置站点名称 1 title = \u0026#34;语梦谈\u0026#34; 设置语言项 注意：这个主题默认是支持多语言的，如果使用多语言，需要分别创建对应的文章，不然会报错，我这里只用到了中文；\n在languages项中，默认有三个语言大项，我删除了其余两个，下面主要展示的是中文的配置内容，同理，只粘贴出我修改过的项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 [languages.zh-cn] weight = 2 # 网站语言, 仅在这里 CN 大写 languageCode = \u0026#34;zh-CN\u0026#34; # 语言名称 languageName = \u0026#34;简体中文\u0026#34; # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # [UA-XXXXXXXX-X] 谷歌分析代号 googleAnalytics = \u0026#34;\u0026#34; # 版权描述，仅仅用于 SEO copyright = \u0026#34;This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\u0026#34; # 菜单配置 [languages.zh-cn.menu] [[languages.zh-cn.menu.main]] identifier = \u0026#34;posts\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;文章\u0026#34; url = \u0026#34;/posts/\u0026#34; title = \u0026#34;\u0026#34; weight = 1 [[languages.zh-cn.menu.main]] identifier = \u0026#34;thinks\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;思考\u0026#34; url = \u0026#34;/thinks/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[languages.zh-cn.menu.main]] identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 3 [[languages.zh-cn.menu.main]] identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;分类\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; weight = 4 [[languages.zh-cn.menu.main]] identifier = \u0026#34;about\u0026#34; pre = \u0026#34;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;关于\u0026#34; url = \u0026#34;/about/\u0026#34; title = \u0026#34;\u0026#34; weight = 5 [[languages.zh-cn.menu.main]] identifier = \u0026#34;github\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-github fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;\u0026#34; url = \u0026#34;https://github.com/jouzeyu\u0026#34; title = \u0026#34;GitHub\u0026#34; weight = 6 [languages.zh-cn.params] # 网站描述 description = \u0026#34;盛年不重来，一日难再晨\u0026#34; # 网站关键词 keywords = [\u0026#34;blog\u0026#34;, \u0026#34;Jouzeyu\u0026#34;] # 应用图标配置 [languages.zh-cn.params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;语梦谈\u0026#34; # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#39;\u0026#39; # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-10 磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;) type = \u0026#34;algolia\u0026#34; # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \u0026#34;index.zh-cn\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; # 主页信息设置 [languages.zh-cn.params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [languages.zh-cn.params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 #gravatarEmail = \u0026#34;jouzeyu@outlook.com\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;https://avatars.githubusercontent.com/u/56755229?v=4\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;语梦谈\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;盛年不重来，一日难再晨\u0026#34; # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # 主页文章列表 [languages.zh-cn.params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 主页的社交信息设置 [languages.zh-cn.params.social] GitHub = \u0026#34;jouzeyu\u0026#34; Linkedin = \u0026#34;\u0026#34; Twitter = \u0026#34;\u0026#34; Instagram = \u0026#34;\u0026#34; Facebook = \u0026#34;\u0026#34; Telegram = \u0026#34;jouzeyu\u0026#34; Medium = \u0026#34;\u0026#34; Gitlab = \u0026#34;\u0026#34; Youtubelegacy = \u0026#34;\u0026#34; Youtubecustom = \u0026#34;\u0026#34; Youtubechannel = \u0026#34;\u0026#34; Tumblr = \u0026#34;\u0026#34; Quora = \u0026#34;\u0026#34; Keybase = \u0026#34;\u0026#34; Pinterest = \u0026#34;\u0026#34; Reddit = \u0026#34;\u0026#34; Codepen = \u0026#34;\u0026#34; FreeCodeCamp = \u0026#34;\u0026#34; Bitbucket = \u0026#34;\u0026#34; Stackoverflow = \u0026#34;\u0026#34; Weibo = \u0026#34;\u0026#34; Odnoklassniki = \u0026#34;\u0026#34; VK = \u0026#34;\u0026#34; Flickr = \u0026#34;\u0026#34; Xing = \u0026#34;\u0026#34; Snapchat = \u0026#34;\u0026#34; Soundcloud = \u0026#34;\u0026#34; Spotify = \u0026#34;\u0026#34; Bandcamp = \u0026#34;\u0026#34; Paypal = \u0026#34;\u0026#34; Fivehundredpx = \u0026#34;\u0026#34; Mix = \u0026#34;\u0026#34; Goodreads = \u0026#34;\u0026#34; Lastfm = \u0026#34;\u0026#34; Foursquare = \u0026#34;\u0026#34; Hackernews = \u0026#34;\u0026#34; Kickstarter = \u0026#34;\u0026#34; Patreon = \u0026#34;\u0026#34; Steam = \u0026#34;\u0026#34; Twitch = \u0026#34;\u0026#34; Strava = \u0026#34;\u0026#34; Skype = \u0026#34;\u0026#34; Whatsapp = \u0026#34;\u0026#34; Zhihu = \u0026#34;\u0026#34; Douban = \u0026#34;\u0026#34; Angellist = \u0026#34;\u0026#34; Slidershare = \u0026#34;\u0026#34; Jsfiddle = \u0026#34;\u0026#34; Deviantart = \u0026#34;\u0026#34; Behance = \u0026#34;\u0026#34; Dribbble = \u0026#34;\u0026#34; Wordpress = \u0026#34;\u0026#34; Vine = \u0026#34;\u0026#34; Googlescholar = \u0026#34;\u0026#34; Researchgate = \u0026#34;\u0026#34; Mastodon = \u0026#34;\u0026#34; Thingiverse = \u0026#34;\u0026#34; Devto = \u0026#34;\u0026#34; Gitea = \u0026#34;\u0026#34; XMPP = \u0026#34;\u0026#34; Matrix = \u0026#34;\u0026#34; Bilibili = \u0026#34;\u0026#34; Email = \u0026#34;jouzeyu@outlook.com\u0026#34; RSS = true 说明：\n菜单配置中标签和分类会自动获取，其他分类需要创建对应的文件夹来存放文章，比如文章对应的是posts，那么创建新文章的时候就是hugo new posts/my-first-post.md; 搜索配置建议选algolia，需要其他额外配置，放在下面讲； 主页的社交信息设置中，是那一项有内容首页就会显示那一项； 线上相关准备 如果想要部署到线上，那么下面的准备工作是必不可少的，另外还需要你有一个备案过的域名（国内的话）\n设置搜索 需要去algolia官网去注册一个账号，可以参考这篇文章：Hugo Algolia 搜索及 Netlify 自动化处理\n设置评论系统 hugo 默认用的是 Valine 评论系统，需要完成这项需要做以下几步：\n注册账号 网址是：https://console.leancloud.cn/\n创建应用 数据存储创建 class 配置安全域名 如果不配置，会提示 Code 403: 访问被 API 域名白名单拒绝，请检查你的安全域名设置.\n绑定域名 这里稍微注意下，这个域名可以用别的二级域名，不用使用原本解析访问的域名。另外如果提示正在部署中，不用着急，它需要等待一会，如果提示 dns 未解析，那按照说明解析就可以了。\n配置到 hugo 1 2 3 appId = \u0026#34;fa7mRg1BGQdKUEs5b5c42rah-gzGzoHsz\u0026#34; #从应用凭证中获取的 appKey = \u0026#34;ekeMLbPcNnMXGj9w30Ehadcj\u0026#34; #从应用凭证中获取的 serverURLs = \u0026#34;https://valine.unlazy.run\u0026#34; #就是上一步你填写的域名 部署到服务器 简单讲下原理，我们写出 markdown 文章，通过 hugo -D 将文章打包成 html 之类的静态访问资源，所以如果你和我一样想部署到服务器时，你只需要将打包生成的 public 文件夹上传到服务器就可以了，不需要在服务器上搭建 hugo，也不需要上传其他的文件；\n这一块有很多中方法，我简单说下我的方法：\n1 2 3 4 5 第一步：通过hugo -D 命令生成静态资源，即public目录 第二步：将public上传到github仓库，这里用了一个本地自己写的脚本 第三步：服务器安装nginx，域名绑定，指向网站所在目录 第四步：生成https证书 第五步：通过定时任务，在服务器上定时运行脚本-将github仓库的内容同步到服务器 相关问题答疑 如果是本地的话，截止到线上相关准备前就已经结束了，你可以本地运行hugo server -D然后访问http://localhost:1313预览网站；\n如果想要部署到github page可能你还需要看看其他文章，因为我还没试过；\n如果你的文章不显示，那需要将 md 文件中的draft选项改为false，这个选项的意思是，该文章是否草稿；\n如果需要加标签，你可以这样写：\n1 2 draft: false tags: [\u0026#34;MySQL\u0026#34;] 如果需要加分类，你可以这样写：\n1 2 draft: false categories: [\u0026#34;MySQL学习\u0026#34;] 如果文中包含照片，可以先放到任意图床中，拿到链接放到文中，当然你也可以用本地文件；\n","permalink":"https://jouzeyu.com/posts/build-blog-with-hugo/","summary":"风是自由的，希望你也是～","title":"hugo搭建个人博客"}]